`ifndef __INSTR_PKG
`define __INSTR_PKG 

`include "verif.pkg"

package instr;
    localparam RV_REG_WIDTH    = 5;
    localparam RV_OPCODE_WIDTH = 7;
    localparam RV_INSTR_WIDTH  = 32;

    import verif::*;

    typedef enum logic[RV_OPCODE_WIDTH-1:0] {
        OP_LUI    = 7'b0110111,
        OP_AUIPC  = 7'b0010111,
        OP_JAL    = 7'b1101111,
        OP_JALR   = 7'b1100111,
        OP_BR     = 7'b1100011,
        OP_LD     = 7'b0000011,
        OP_ST     = 7'b0100011,
        OP_ALU_I  = 7'b0010011,
        OP_ALU_R  = 7'b0110011,
        OP_FENCE  = 7'b0001111,
        OP_MISC   = 7'b1110011
    } t_rv_opcode;

    typedef logic[RV_REG_WIDTH-1:0] t_rv_reg;

    // RISC-V Instruction descriptor formats

    typedef enum logic[2:0] {
        RV_FMT_R,
        RV_FMT_I,
        RV_FMT_S,
        RV_FMT_B,
        RV_FMT_U,
        RV_FMT_J
    } t_rv_instr_format;

    typedef struct packed {
        logic[6:0]  funct7;
        t_rv_reg    rs2;
        t_rv_reg    rs1;
        logic[2:0]  funct3;
        t_rv_reg    rd;
    } t_instr_R_descr;

    typedef struct packed {
        logic[11:0] imm_11_0;
        t_rv_reg    rs1;
        logic[2:0]  funct3;
        t_rv_reg    rd;
    } t_instr_I_descr;

    typedef struct packed {
        logic[11:5] imm_11_5;
        t_rv_reg    rs2;
        t_rv_reg    rs1;
        logic[2:0]  funct3;
        logic[4:0]  imm_4_0;
    } t_instr_S_descr;

    typedef struct packed {
        logic[12:12] imm_12;
        logic[10:5]  imm_10_5;
        t_rv_reg     rs2;
        t_rv_reg     rs1;
        logic[2:0]   funct3;
        logic[4:1]   imm_4_1;
        logic[11:11] imm_11;
    } t_instr_B_descr;

    typedef struct packed {
        logic[31:12] imm_31_12;
        t_rv_reg    rd;
    } t_instr_U_descr;

    typedef struct packed {
        logic[20:20] imm_20;
        logic[10:1]  imm_10_1;
        logic[11:11] imm_11;
        logic[19:12] imm_19_12;
        t_rv_reg    rd;
    } t_instr_J_descr;

    typedef union packed {
        t_instr_R_descr  R;
        t_instr_I_descr  I;
        t_instr_S_descr  S;
        t_instr_B_descr  B;
        t_instr_U_descr  U;
        t_instr_J_descr  J;
    } t_instr_descr;

    // RISC-V Instruction formats

    typedef struct packed {
        `SIMID_STRUCT
        t_instr_descr d;
        t_rv_opcode   opcode;
    } t_rv_instr;

    // Expanded uop format

    typedef enum logic[1:0] {
        SZ_INV = 2'b00,
        SZ_1B  = 2'b01,
        SZ_2B  = 2'b10,
        SZ_4B  = 2'b11
    } t_size;

    typedef enum logic[2:0] {
        OP_INVD,
        OP_ZERO,
        OP_IMM,
        OP_REG,
        OP_MEM
    } t_optype;

    typedef struct packed {
        t_size   opsize;
        t_optype optype;
        t_rv_reg opreg;
    } t_uopnd;

    typedef struct packed {
        `SIMID_STRUCT
        logic[31:0]       imm32;
        logic[6:0]        funct7;
        logic[2:0]        funct3;
        t_uopnd           src2;
        t_uopnd           src1;
        t_uopnd           dst;
        t_rv_opcode       opcode;
        t_rv_instr_format ifmt;
        logic             valid;
    } t_uinstr;

    `ifdef SIMULATION
    function string describe_uinstr(t_uinstr uinstr);
        describe_uinstr = $sformatf("opcode:%s ifmt:%s", uinstr.opcode.name(), uinstr.ifmt.name());
        case (uinstr.ifmt)
            RV_FMT_I: describe_uinstr = $sformatf("%s rd:x%-d rs1:x%-d imm32:0x%h funct3:%-d", describe_uinstr, uinstr.dst.opreg, uinstr.src1.opreg, uinstr.imm32, uinstr.funct3);
            RV_FMT_R: describe_uinstr = $sformatf("%s rd:x%-d rs1:x%-d rs2:x%-d funct3:%-d funct7:%-d", describe_uinstr, uinstr.dst.opreg, uinstr.src1.opreg, uinstr.src2.opreg, uinstr.funct3, uinstr.funct7);
            default:  describe_uinstr = describe_uinstr;
        endcase
    endfunction
    `endif

endpackage

`endif // __INSTR_PKG 
