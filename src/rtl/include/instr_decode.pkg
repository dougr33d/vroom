`ifndef __INSTR_DECODE_PKG
`define __INSTR_DECODE_PKG

`include "instr.pkg"
`include "verif.pkg"
`include "common.pkg"

package instr_decode;
    import instr::*;
    import common::*;
    import verif::*;

    typedef enum logic[4:0] {
        U_INVALID,
        U_ADD,
        U_ADDW,
        U_SUB,
        U_SUBW,
        U_SLL,
        U_SLLW,
        U_SLT,
        U_SLTU,
        U_XOR,
        U_SRL,
        U_SRLW,
        U_SRA,
        U_SRAW,
        U_OR,
        U_AND,
        U_BR,
        U_LOAD,
        U_STORE,
        U_EBREAK,
        U_ECALL,
        U_AUIPC,
        U_LUI,
        U_JAL,
        U_JALR
    } t_uop;

    typedef struct packed {
        t_size   opsize;
        t_optype optype;
        t_rv_reg_addr opreg;
    } t_uopnd_descr;

    typedef struct packed {
        `SIMID_STRUCT
        logic[63:0]       imm64;
        logic[6:0]        funct7;
        logic             mispred;
        t_rv_funct3       funct3;
        t_uopnd_descr     src2;
        t_uopnd_descr     src1;
        t_uopnd_descr     dst;
        t_rv_opcode       opcode;
        t_rv_instr_format ifmt;
        t_uop             uop;
        t_paddr           pc;
        logic             valid;
    } t_uinstr;

    typedef logic[RV_REG_ADDR_BITS-1:0] t_gpr_id;

    typedef struct packed {
        t_prf_id psrc1;
        logic    psrc1_pend;
        t_prf_id psrc2;
        logic    psrc2_pend;
        t_prf_id pdst;
        t_prf_id pdst_old;
        t_rob_id robid;
    } t_rename_pkt;

    typedef struct packed {
        t_ldq_id ldqid;
        t_stq_id stqid;
    } t_disp_meta_mem;

    typedef union packed {
        t_disp_meta_mem mem;
    } t_disp_meta;

    typedef struct packed {
       t_uinstr     uinstr;
       t_rename_pkt rename;
       t_disp_meta  meta;
    } t_disp_pkt;

    typedef struct packed {
       t_uinstr      uinstr;
       t_rob_id      robid;
       t_prf_id      pdst;
       t_rv_reg_data src1_val;
       t_rv_reg_data src2_val;
       logic[63:0]   imm64;
       t_disp_meta   meta;
    } t_iss_pkt;

    typedef struct packed {
        `SIMID_STRUCT
        t_prf_id      pdst;
        instr::t_rv_reg_data data;
    } t_prf_wr_pkt;

    function logic rv_opcode_is_alu(t_rv_opcode opcode);
        return opcode inside {RV_OP_ALU0_I, RV_OP_ALU1_I, RV_OP_ALU0_R, RV_OP_ALU0_I};
    endfunction

    function logic rv_opcode_is_st(t_rv_opcode opcode);
        return opcode inside {RV_OP_ST};
    endfunction

    function logic rv_opcode_is_ld(t_rv_opcode opcode);
        return opcode inside {RV_OP_LD};
    endfunction

    function logic rv_opcode_is_ldst(t_rv_opcode opcode);
        return rv_opcode_is_ld(opcode) | rv_opcode_is_st(opcode);
    endfunction

    function t_rv_instr_format get_instr_format (t_rv_opcode opcode);
        unique casez (opcode)
            RV_OP_LUI   : get_instr_format = RV_FMT_U;
            RV_OP_AUIPC : get_instr_format = RV_FMT_U;
            RV_OP_JAL   : get_instr_format = RV_FMT_J;
            RV_OP_JALR  : get_instr_format = RV_FMT_I;
            RV_OP_BR    : get_instr_format = RV_FMT_B;
            RV_OP_LD    : get_instr_format = RV_FMT_I;
            RV_OP_ST    : get_instr_format = RV_FMT_S;
            RV_OP_ALU0_I : get_instr_format = RV_FMT_I;
            RV_OP_ALU1_I : get_instr_format = RV_FMT_I;
            RV_OP_ALU0_R : get_instr_format = RV_FMT_R;
            RV_OP_ALU1_R : get_instr_format = RV_FMT_R;
            RV_OP_FENCE  : get_instr_format = RV_FMT_I;
            RV_OP_SYSTEM : get_instr_format = RV_FMT_I;
        endcase
    endfunction

    function automatic t_uop rv_instr_to_uop (t_rv_instr instr);
        t_rv_instr_format ifmt = get_instr_format(instr.opcode);
        rv_instr_to_uop = U_INVALID;
        unique casez (ifmt)
            RV_FMT_R: begin
                // opcode = RV_OP_ALU_R
                t_rv_alu_op_funct3 alu_op = t_rv_alu_op_funct3'(instr.d.R.funct3);
                unique casez(instr.opcode)
                    RV_OP_ALU0_R:
                        unique casez(alu_op)
                            ALU_ADD:  rv_instr_to_uop = instr.d.R.funct7[5] ? U_SUB : U_ADD;
                            ALU_SHL:  rv_instr_to_uop = U_SLL;
                            ALU_SLT:  rv_instr_to_uop = U_SLT;
                            ALU_SLTU: rv_instr_to_uop = U_SLTU;
                            ALU_XOR:  rv_instr_to_uop = U_XOR;
                            ALU_SHR:  rv_instr_to_uop = instr.d.R.funct7[5] ? U_SRA : U_SRL;
                            ALU_OR:   rv_instr_to_uop = U_OR;
                            ALU_AND:  rv_instr_to_uop = U_AND;
                        endcase
                    RV_OP_ALU1_R:
                        unique casez(alu_op)
                            ALU_ADD:  rv_instr_to_uop = instr.d.R.funct7[5] ? U_SUBW : U_ADDW;
                            ALU_SHL:  rv_instr_to_uop = U_SLLW;
                            ALU_SHR:  rv_instr_to_uop = instr.d.R.funct7[5] ? U_SRAW : U_SRLW;
                            default:  rv_instr_to_uop = U_INVALID;
                        endcase
                    default:
                        rv_instr_to_uop = U_INVALID;
                endcase

            end
            RV_FMT_I: begin
                unique casez(instr.opcode)
                    RV_OP_JALR  : rv_instr_to_uop = U_INVALID;
                    RV_OP_LD    : begin
                        //t_rv_ld_op_funct3 ld_op = t_rv_ld_op_funct3'(instr.d.I.funct3);
                        rv_instr_to_uop = U_LOAD;
                    end
                    RV_OP_ST    : begin
                        //t_rv_st_op_funct3 st_op = t_rv_st_op_funct3'(instr.d.I.funct3);
                        rv_instr_to_uop = U_STORE;
                    end
                    RV_OP_ALU0_I : begin
                        t_rv_alu_op_funct3 alu_op = t_rv_alu_op_funct3'(instr.d.R.funct3);
                        unique casez(alu_op)
                            ALU_ADD:  rv_instr_to_uop = U_ADD;
                            ALU_SHL:  rv_instr_to_uop = U_SLL;
                            ALU_SLT:  rv_instr_to_uop = U_SLT;
                            ALU_SLTU: rv_instr_to_uop = U_SLTU;
                            ALU_XOR:  rv_instr_to_uop = U_XOR;
                            ALU_SHR:  rv_instr_to_uop = instr.d.R.funct7[5] ? U_SRA : U_SRL; // same as R-type decode
                            ALU_OR:   rv_instr_to_uop = U_OR;
                            ALU_AND:  rv_instr_to_uop = U_AND;
                        endcase
                    end
                    RV_OP_ALU1_I : begin
                        t_rv_alu_op_funct3 alu_op = t_rv_alu_op_funct3'(instr.d.R.funct3);
                        unique casez(alu_op)
                            ALU_ADD:  rv_instr_to_uop = U_ADDW;
                            ALU_SHL:  rv_instr_to_uop = U_SLLW;
                            ALU_SHR:  rv_instr_to_uop = instr.d.R.funct7[5] ? U_SRAW : U_SRLW; // same as R-type decode
                            default:  rv_instr_to_uop = U_INVALID;
                        endcase
                    end
                    RV_OP_FENCE : rv_instr_to_uop = U_INVALID;
                    RV_OP_SYSTEM: begin
                        t_rv_sys_op_funct3 sys_op = t_rv_sys_op_funct3'(instr.d.I.funct3);
                        unique casez(sys_op)
                            RV_SYS_ECALL_EBREAK: rv_instr_to_uop = instr.d.I.imm_11_0[0] ? U_EBREAK : U_ECALL;
                            default:             rv_instr_to_uop = U_INVALID;
                        endcase
                    end
                    default  : rv_instr_to_uop = U_INVALID;
                endcase
            end
            RV_FMT_J: begin
                unique casez(instr.opcode)
                    RV_OP_JAL: rv_instr_to_uop = U_JAL;
                    default:   rv_instr_to_uop = U_INVALID;
                endcase
            end
            RV_FMT_U: begin
                // opcode = RV_OP_ALU_R
                unique casez(instr.opcode)
                    RV_OP_LUI:   rv_instr_to_uop = U_LUI;
                    RV_OP_AUIPC: rv_instr_to_uop = U_AUIPC;
                    default:     rv_instr_to_uop = U_INVALID;
                endcase
            end
            RV_FMT_S: begin
                unique casez(instr.opcode)
                    RV_OP_ST    : begin
                        //t_rv_st_op_funct3 st_op = t_rv_st_op_funct3'(instr.d.I.funct3);
                        rv_instr_to_uop = U_STORE;
                    end
                    default:     rv_instr_to_uop = U_INVALID;
                endcase
            end
            RV_FMT_B: begin
                unique casez(instr.opcode)
                    RV_OP_BR: rv_instr_to_uop = U_BR;
                    default: rv_instr_to_uop = U_INVALID;
                endcase
            end
        endcase
    endfunction

    function logic[RV_NUM_REGS-1:0] uinstr_to_rdmask(t_uinstr u);
        if (!u.valid) begin
            uinstr_to_rdmask = '0;
        end else begin
            uinstr_to_rdmask = '0;
            if (u.src1.optype == OP_REG) uinstr_to_rdmask[u.src1.opreg] = 1'b1;
            if (u.src2.optype == OP_REG) uinstr_to_rdmask[u.src2.opreg] = 1'b1;
        end
    endfunction

    function logic[RV_NUM_REGS-1:0] uinstr_to_wrmask(t_uinstr u);
        if (!u.valid) begin
            uinstr_to_wrmask = '0;
        end else begin
            uinstr_to_wrmask = '0;
            if (u.dst.optype == OP_REG) uinstr_to_wrmask[u.dst.opreg] = 1'b1;
        end
    endfunction

    typedef enum logic[1:0] {
        FU_INVALID,
        FU_EXE,
        FU_MEM
    } t_fu_type;

    function t_fu_type uop_to_fu(t_uop uop);
        unique casez(uop)
            U_INVALID: uop_to_fu = FU_INVALID;
            U_ADD:     uop_to_fu = FU_EXE;
            U_ADDW:    uop_to_fu = FU_EXE;
            U_SUB:     uop_to_fu = FU_EXE;
            U_SUBW:    uop_to_fu = FU_EXE;
            U_SLL:     uop_to_fu = FU_EXE;
            U_SLLW:    uop_to_fu = FU_EXE;
            U_SLT:     uop_to_fu = FU_EXE;
            U_SLTU:    uop_to_fu = FU_EXE;
            U_XOR:     uop_to_fu = FU_EXE;
            U_SRL:     uop_to_fu = FU_EXE;
            U_SRLW:    uop_to_fu = FU_EXE;
            U_SRA:     uop_to_fu = FU_EXE;
            U_SRAW:    uop_to_fu = FU_EXE;
            U_OR:      uop_to_fu = FU_EXE;
            U_AND:     uop_to_fu = FU_EXE;
            U_BR:      uop_to_fu = FU_EXE;
            U_LOAD:    uop_to_fu = FU_MEM;
            U_STORE:   uop_to_fu = FU_MEM;
            U_EBREAK:  uop_to_fu = FU_EXE;
            U_ECALL:   uop_to_fu = FU_EXE;
            U_AUIPC:   uop_to_fu = FU_EXE;
            U_LUI:     uop_to_fu = FU_EXE;
            U_JAL:     uop_to_fu = FU_EXE;
            U_JALR:    uop_to_fu = FU_EXE;
        endcase
    endfunction

    `ifdef SIMULATION
    function string f_describe_opnd_descr(t_uopnd_descr op);
        string opsize_char;
        unique casez(op.opsize)
            SZ_1B: opsize_char = "B";
            SZ_2B: opsize_char = "H";
            SZ_4B: opsize_char = "W";
            SZ_8B: opsize_char = "D";
            default: opsize_char = "?";
        endcase
        unique casez(op.optype)
            OP_REG:  f_describe_opnd_descr = $sformatf("%s.%s", $sformatf("x%0d",op.opreg), opsize_char);
            OP_IMM:  f_describe_opnd_descr = $sformatf("imm");
            OP_ZERO: f_describe_opnd_descr = $sformatf("zero");
            OP_INVD: f_describe_opnd_descr = $sformatf("invalid");
            OP_MEM:  f_describe_opnd_descr = $sformatf("mem.%s", opsize_char);
        endcase
    endfunction

    function string describe_uinstr(t_uinstr uinstr);
        describe_uinstr = $sformatf("opcode:%s uop:%s ifmt:%s", uinstr.opcode.name(), uinstr.uop.name(), uinstr.ifmt.name());
        case (uinstr.ifmt)
            RV_FMT_I: describe_uinstr = $sformatf("%s dst:%s src1:%s imm64:0x%h funct3:%-d", describe_uinstr, f_describe_opnd_descr(uinstr.dst), f_describe_opnd_descr(uinstr.src1), uinstr.imm64, uinstr.funct3);
            RV_FMT_R: describe_uinstr = $sformatf("%s dst:%s src1:%s src2:%s funct3:%-d funct7:%-d", describe_uinstr, f_describe_opnd_descr(uinstr.dst), f_describe_opnd_descr(uinstr.src1), f_describe_opnd_descr(uinstr.src2), uinstr.funct3, uinstr.funct7);
            RV_FMT_S: describe_uinstr = $sformatf("%s dst:%s src1:%s src2:%s imm64:0x%h", describe_uinstr, f_describe_opnd_descr(uinstr.dst), f_describe_opnd_descr(uinstr.src1), f_describe_opnd_descr(uinstr.src2), uinstr.imm64);
            RV_FMT_U: describe_uinstr = $sformatf("%s dst:%s imm64:0x%h", describe_uinstr, f_describe_opnd_descr(uinstr.dst), uinstr.imm64);
            RV_FMT_J: describe_uinstr = $sformatf("%s dst:%s imm64:0x%h", describe_uinstr, f_describe_opnd_descr(uinstr.dst), uinstr.imm64);
            default:  describe_uinstr = describe_uinstr;
        endcase
    endfunction

    function string describe_opnd(t_uopnd_descr opnd, logic[63:0] val64);
        unique case (opnd.optype)
            OP_REG:  describe_opnd = $sformatf("reg,x%-2d 0x%016h", opnd.opreg, val64);
            OP_IMM:  describe_opnd = $sformatf("imm     0x%016h", val64);
            default: describe_opnd = "UNDEF";
        endcase
    endfunction

    function void print_retire_info(t_uinstr uinstr_rb0);
        `RETLOG(("-------------------------------------"))
        `RETLOG(("PC:%08h %s -> %s", uinstr_rb0.SIMID.pc, uinstr_rb0.opcode.name(), uinstr_rb0.uop.name()))
    endfunction
    `endif

endpackage

`endif // __INSTR_DECODE_PKG
